"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const concurrently = require("concurrently");
const spawn = require("cross-spawn");
const defaultOptions = {
    projectName: 'app',
    tsServerConfigFile: 'server/tsconfig.json',
    watchDir: 'dist',
    serverBundlePath: 'dist/server/main.js',
    serverFilePath: 'dist/server-app/main',
    mainBundlePath: 'dist/browser/main.js',
    indexFilePath: 'dist/browser/index.html',
    outputDir: 'dist',
    watchSsr: true
};
class LiveReloadCompiler {
    constructor(options = { projectName: 'app' }) {
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const { indexFilePath, projectName, tsServerConfigFile, watchDir, serverFilePath, outputDir, watchSsr, serverBundlePath, liveReloadOptions } = this.options;
            let PREBUILD_SCRIPT = `rimraf ${outputDir}`;
            if (!watchSsr) {
                PREBUILD_SCRIPT += `&& ng run ${projectName}:server:production`;
            }
            const script = spawn(`${PREBUILD_SCRIPT}`, {
                shell: true,
                stdio: 'inherit'
            });
            const livereload = require('livereload');
            const server = livereload.createServer(Object.assign({ delay: 300 }, (liveReloadOptions || {})));
            server.watch(outputDir);
            process.on('SIGINT', () => {
                try {
                    server && server.close();
                }
                catch (_a) { }
                process.exit();
            });
            script.on('exit', code => {
                if (code !== 0) {
                    return;
                }
                const commands = [
                    'ng build --aot --watch --delete-output-path=false',
                    `tsc --watch -p ${tsServerConfigFile}`
                ];
                if (watchSsr) {
                    commands.push(`wait-on ${indexFilePath} && wait-on ${serverBundlePath} && nodemon --watch ${watchDir} --delay 1 ${serverFilePath}`);
                    commands.push(`ng run ${projectName}:server:production --watch`);
                }
                else {
                    commands.push(`wait-on ${indexFilePath} && nodemon --watch ${watchDir} --delay 1 ${serverFilePath}`);
                }
                concurrently(commands, {
                    raw: true,
                    killOthers: true
                });
            });
        });
    }
}
exports.LiveReloadCompiler = LiveReloadCompiler;
