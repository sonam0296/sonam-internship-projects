/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/index", ["require", "exports", "@angular-devkit/architect", "child_process", "fs", "path", "@nguniversal/builders/src/prerender/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execute = void 0;
    const architect_1 = require("@angular-devkit/architect");
    const child_process_1 = require("child_process");
    const fs = require("fs");
    const path = require("path");
    const utils_1 = require("@nguniversal/builders/src/prerender/utils");
    /**
     * Schedules the server and browser builds and returns their results if both builds are successful.
     */
    function _scheduleBuilds(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
            const browserTargetRun = yield context.scheduleTarget(browserTarget, {
                watch: false,
                serviceWorker: false,
            });
            const serverTargetRun = yield context.scheduleTarget(serverTarget, {
                watch: false,
            });
            try {
                const [browserResult, serverResult] = yield Promise.all([
                    browserTargetRun.result,
                    serverTargetRun.result,
                ]);
                const success = browserResult.success && serverResult.success && browserResult.baseOutputPath !== undefined;
                const error = browserResult.error || serverResult.error;
                return { success, error, browserResult, serverResult };
            }
            catch (e) {
                return { success: false, error: e.message };
            }
            finally {
                yield Promise.all([browserTargetRun.stop(), serverTargetRun.stop()]);
            }
        });
    }
    function _parallelRenderRoutes(shardedRoutes, context, indexHtml, outputPath, indexFile, serverBundlePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const workerFile = path.join(__dirname, 'render.js');
            const childProcesses = shardedRoutes.map(routes => new Promise((resolve, reject) => {
                child_process_1.fork(workerFile, [
                    indexHtml,
                    indexFile,
                    serverBundlePath,
                    outputPath,
                    ...routes,
                ])
                    .on('message', data => {
                    if (data.success) {
                        context.logger.info(`CREATE ${data.outputIndexPath} (${data.bytes} bytes)`);
                    }
                    else {
                        context.logger.error(`Error: ${data.error.message}`);
                        context.logger.error(`Unable to render ${data.outputIndexPath}`);
                    }
                })
                    .on('exit', resolve)
                    .on('error', reject);
            }));
            yield Promise.all(childProcesses);
        });
    }
    /**
     * Renders each route and writes them to
     * <route>/index.html for each output path in the browser result.
     */
    function _renderUniversal(routes, context, browserResult, serverResult, browserOptions, numProcesses) {
        return __awaiter(this, void 0, void 0, function* () {
            // Users can specify a different base html file e.g. "src/home.html"
            const indexFile = utils_1.getIndexOutputFile(browserOptions);
            // We need to render the routes for each locale from the browser output.
            for (const outputPath of browserResult.outputPaths) {
                const browserIndexInputPath = path.join(outputPath, indexFile);
                const indexHtml = fs.readFileSync(browserIndexInputPath, 'utf8');
                const { baseOutputPath = '' } = serverResult;
                const localeDirectory = path.relative(browserResult.baseOutputPath, outputPath);
                const serverBundlePath = path.join(baseOutputPath, localeDirectory, 'main.js');
                if (!fs.existsSync(serverBundlePath)) {
                    throw new Error(`Could not find the main bundle: ${serverBundlePath}`);
                }
                const shardedRoutes = utils_1.shardArray(routes, numProcesses);
                context.logger.info(`\nPrerendering ${routes.length} route(s) to ${outputPath}`);
                yield _parallelRenderRoutes(shardedRoutes, context, indexHtml, outputPath, indexFile, serverBundlePath);
            }
            return browserResult;
        });
    }
    /**
     * Builds the browser and server, then renders each route in options.routes
     * and writes them to prerender/<route>/index.html for each output path in
     * the browser result.
     */
    function execute(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const browserOptions = yield context.getTargetOptions(browserTarget);
            const tsConfigPath = typeof browserOptions.tsConfig === 'string' ? browserOptions.tsConfig : undefined;
            const routes = yield utils_1.getRoutes(options, tsConfigPath, context);
            if (!routes.length) {
                throw new Error(`Could not find any routes to prerender.`);
            }
            const result = yield _scheduleBuilds(options, context);
            const { success, error, browserResult, serverResult } = result;
            if (!success || !browserResult || !serverResult) {
                return { success, error };
            }
            return _renderUniversal(routes, context, browserResult, serverResult, browserOptions, options.numProcesses);
        });
    }
    exports.execute = execute;
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9wcmVyZW5kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgseURBQWlIO0lBRWpILGlEQUFxQztJQUNyQyx5QkFBeUI7SUFDekIsNkJBQTZCO0lBRzdCLHFFQUFvRTtJQWFwRTs7T0FFRztJQUNILFNBQWUsZUFBZSxDQUM1QixPQUFnQyxFQUNoQyxPQUF1Qjs7WUFFdkIsTUFBTSxhQUFhLEdBQUcsa0NBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sWUFBWSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUVsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUU7Z0JBQ25FLEtBQUssRUFBRSxLQUFLO2dCQUNaLGFBQWEsRUFBRSxLQUFLO2FBRXJCLENBQUMsQ0FBQztZQUNILE1BQU0sZUFBZSxHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pFLEtBQUssRUFBRSxLQUFLO2FBQ2IsQ0FBQyxDQUFDO1lBRUgsSUFBSTtnQkFDRixNQUFNLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQztvQkFDdEQsZ0JBQWdCLENBQUMsTUFBdUM7b0JBQ3hELGVBQWUsQ0FBQyxNQUF1QztpQkFDeEQsQ0FBQyxDQUFDO2dCQUVILE1BQU0sT0FBTyxHQUNYLGFBQWEsQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sSUFBSSxhQUFhLENBQUMsY0FBYyxLQUFLLFNBQVMsQ0FBQztnQkFDOUYsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLEtBQUssSUFBSSxZQUFZ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QUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxDQUFDO1lBQy9ELElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFtQixDQUFDO2FBQzVDO1lBRUQsT0FBTyxnQkFBZ0IsQ0FDckIsTUFBTSxFQUNOLE9BQU8sRUFDUCxhQUFhLEVBQ2IsWUFBWSxFQUNaLGNBQWMsRUFDZCxPQUFPLENBQUMsWUFBWSxDQUNyQixDQUFDO1FBQ0osQ0FBQztLQUFBO0lBN0JELDBCQTZCQztJQUVELGtCQUFlLHlCQUFhLENBQUMsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHsgQnVpbGRlckNvbnRleHQsIEJ1aWxkZXJPdXRwdXQsIGNyZWF0ZUJ1aWxkZXIsIHRhcmdldEZyb21UYXJnZXRTdHJpbmcgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvYXJjaGl0ZWN0JztcbmltcG9ydCB7IEJyb3dzZXJCdWlsZGVyT3B0aW9ucyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyJztcbmltcG9ydCB7IGZvcmsgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IFByZXJlbmRlckJ1aWxkZXJPcHRpb25zLCBQcmVyZW5kZXJCdWlsZGVyT3V0cHV0IH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgZ2V0SW5kZXhPdXRwdXRGaWxlLCBnZXRSb3V0ZXMsIHNoYXJkQXJyYXkgfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBCdWlsZEJ1aWxkZXJPdXRwdXQgPSBCdWlsZGVyT3V0cHV0ICYge1xuICBiYXNlT3V0cHV0UGF0aDogc3RyaW5nO1xuICBvdXRwdXRQYXRoczogc3RyaW5nW107XG4gIG91dHB1dFBhdGg6IHN0cmluZztcbn07XG5cbnR5cGUgU2NoZWR1bGVCdWlsZHNPdXRwdXQgPSBCdWlsZGVyT3V0cHV0ICYge1xuICBzZXJ2ZXJSZXN1bHQ/OiBCdWlsZEJ1aWxkZXJPdXRwdXQ7XG4gIGJyb3dzZXJSZXN1bHQ/OiBCdWlsZEJ1aWxkZXJPdXRwdXQ7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlcyB0aGUgc2VydmVyIGFuZCBicm93c2VyIGJ1aWxkcyBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzIGlmIGJvdGggYnVpbGRzIGFyZSBzdWNjZXNzZnVsLlxuICovXG5hc3luYyBmdW5jdGlvbiBfc2NoZWR1bGVCdWlsZHMoXG4gIG9wdGlvbnM6IFByZXJlbmRlckJ1aWxkZXJPcHRpb25zLFxuICBjb250ZXh0OiBCdWlsZGVyQ29udGV4dFxuKTogUHJvbWlzZTxTY2hlZHVsZUJ1aWxkc091dHB1dD4ge1xuICBjb25zdCBicm93c2VyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLmJyb3dzZXJUYXJnZXQpO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuc2VydmVyVGFyZ2V0KTtcblxuICBjb25zdCBicm93c2VyVGFyZ2V0UnVuID0gYXdhaXQgY29udGV4dC5zY2hlZHVsZVRhcmdldChicm93c2VyVGFyZ2V0LCB7XG4gICAgd2F0Y2g6IGZhbHNlLFxuICAgIHNlcnZpY2VXb3JrZXI6IGZhbHNlLFxuICAgIC8vIHRvZG86IGhhbmRsZSBzZXJ2aWNlIHdvcmtlciBhdWdtZW50YXRpb25cbiAgfSk7XG4gIGNvbnN0IHNlcnZlclRhcmdldFJ1biA9IGF3YWl0IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoc2VydmVyVGFyZ2V0LCB7XG4gICAgd2F0Y2g6IGZhbHNlLFxuICB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IFticm93c2VyUmVzdWx0LCBzZXJ2ZXJSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgYnJvd3NlclRhcmdldFJ1bi5yZXN1bHQgYXMgdW5rbm93biBhcyBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gICAgICBzZXJ2ZXJUYXJnZXRSdW4ucmVzdWx0IGFzIHVua25vd24gYXMgQnVpbGRCdWlsZGVyT3V0cHV0LFxuICAgIF0pO1xuXG4gICAgY29uc3Qgc3VjY2VzcyA9XG4gICAgICBicm93c2VyUmVzdWx0LnN1Y2Nlc3MgJiYgc2VydmVyUmVzdWx0LnN1Y2Nlc3MgJiYgYnJvd3NlclJlc3VsdC5iYXNlT3V0cHV0UGF0aCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVycm9yID0gYnJvd3NlclJlc3VsdC5lcnJvciB8fCBzZXJ2ZXJSZXN1bHQuZXJyb3IgYXMgc3RyaW5nO1xuXG4gICAgcmV0dXJuIHsgc3VjY2VzcywgZXJyb3IsIGJyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdCB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbYnJvd3NlclRhcmdldFJ1bi5zdG9wKCksIHNlcnZlclRhcmdldFJ1bi5zdG9wKCldKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfcGFyYWxsZWxSZW5kZXJSb3V0ZXMoXG4gIHNoYXJkZWRSb3V0ZXM6IHN0cmluZ1tdW10sXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0LFxuICBpbmRleEh0bWw6IHN0cmluZyxcbiAgb3V0cHV0UGF0aDogc3RyaW5nLFxuICBpbmRleEZpbGU6IHN0cmluZyxcbiAgc2VydmVyQnVuZGxlUGF0aDogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHdvcmtlckZpbGUgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAncmVuZGVyLmpzJyk7XG4gIGNvbnN0IGNoaWxkUHJvY2Vzc2VzID0gc2hhcmRlZFJvdXRlcy5tYXAocm91dGVzID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZm9yayh3b3JrZXJGaWxlLCBbXG4gICAgICAgIGluZGV4SHRtbCxcbiAgICAgICAgaW5kZXhGaWxlLFxuICAgICAgICBzZXJ2ZXJCdW5kbGVQYXRoLFxuICAgICAgICBvdXRwdXRQYXRoLFxuICAgICAgICAuLi5yb3V0ZXMsXG4gICAgICBdKVxuICAgICAgICAub24oJ21lc3NhZ2UnLCBkYXRhID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5pbmZvKGBDUkVBVEUgJHtkYXRhLm91dHB1dEluZGV4UGF0aH0gKCR7ZGF0YS5ieXRlc30gYnl0ZXMpYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmVycm9yKGBFcnJvcjogJHtkYXRhLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5lcnJvcihgVW5hYmxlIHRvIHJlbmRlciAke2RhdGEub3V0cHV0SW5kZXhQYXRofWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdleGl0JywgcmVzb2x2ZSlcbiAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgfSlcbiAgKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZFByb2Nlc3Nlcyk7XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGFuZCB3cml0ZXMgdGhlbSB0b1xuICogPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluIHRoZSBicm93c2VyIHJlc3VsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmRlclVuaXZlcnNhbChcbiAgcm91dGVzOiBzdHJpbmdbXSxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4gIGJyb3dzZXJSZXN1bHQ6IEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgc2VydmVyUmVzdWx0OiBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gIGJyb3dzZXJPcHRpb25zOiBCcm93c2VyQnVpbGRlck9wdGlvbnMsXG4gIG51bVByb2Nlc3Nlcz86IG51bWJlcixcbik6IFByb21pc2U8QnVpbGRCdWlsZGVyT3V0cHV0PiB7XG4gIC8vIFVzZXJzIGNhbiBzcGVjaWZ5IGEgZGlmZmVyZW50IGJhc2UgaHRtbCBmaWxlIGUuZy4gXCJzcmMvaG9tZS5odG1sXCJcbiAgY29uc3QgaW5kZXhGaWxlID0gZ2V0SW5kZXhPdXRwdXRGaWxlKGJyb3dzZXJPcHRpb25zKTtcbiAgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIHJvdXRlcyBmb3IgZWFjaCBsb2NhbGUgZnJvbSB0aGUgYnJvd3NlciBvdXRwdXQuXG4gIGZvciAoY29uc3Qgb3V0cHV0UGF0aCBvZiBicm93c2VyUmVzdWx0Lm91dHB1dFBhdGhzKSB7XG4gICAgY29uc3QgYnJvd3NlckluZGV4SW5wdXRQYXRoID0gcGF0aC5qb2luKG91dHB1dFBhdGgsIGluZGV4RmlsZSk7XG4gICAgY29uc3QgaW5kZXhIdG1sID0gZnMucmVhZEZpbGVTeW5jKGJyb3dzZXJJbmRleElucHV0UGF0aCwgJ3V0ZjgnKTtcblxuICAgIGNvbnN0IHsgYmFzZU91dHB1dFBhdGggPSAnJyB9ID0gc2VydmVyUmVzdWx0O1xuICAgIGNvbnN0IGxvY2FsZURpcmVjdG9yeSA9IHBhdGgucmVsYXRpdmUoYnJvd3NlclJlc3VsdC5iYXNlT3V0cHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgY29uc3Qgc2VydmVyQnVuZGxlUGF0aCA9IHBhdGguam9pbihiYXNlT3V0cHV0UGF0aCwgbG9jYWxlRGlyZWN0b3J5LCAnbWFpbi5qcycpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhzZXJ2ZXJCdW5kbGVQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB0aGUgbWFpbiBidW5kbGU6ICR7c2VydmVyQnVuZGxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFyZGVkUm91dGVzID0gc2hhcmRBcnJheShyb3V0ZXMsIG51bVByb2Nlc3Nlcyk7XG4gICAgY29udGV4dC5sb2dnZXIuaW5mbyhgXFxuUHJlcmVuZGVyaW5nICR7cm91dGVzLmxlbmd0aH0gcm91dGUocykgdG8gJHtvdXRwdXRQYXRofWApO1xuXG4gICAgYXdhaXQgX3BhcmFsbGVsUmVuZGVyUm91dGVzKFxuICAgICAgc2hhcmRlZFJvdXRlcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBpbmRleEh0bWwsXG4gICAgICBvdXRwdXRQYXRoLFxuICAgICAgaW5kZXhGaWxlLFxuICAgICAgc2VydmVyQnVuZGxlUGF0aCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJSZXN1bHQ7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIsIHRoZW4gcmVuZGVycyBlYWNoIHJvdXRlIGluIG9wdGlvbnMucm91dGVzXG4gKiBhbmQgd3JpdGVzIHRoZW0gdG8gcHJlcmVuZGVyLzxyb3V0ZT4vaW5kZXguaHRtbCBmb3IgZWFjaCBvdXRwdXQgcGF0aCBpblxuICogdGhlIGJyb3dzZXIgcmVzdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZShcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0XG4pOiBQcm9taXNlPFByZXJlbmRlckJ1aWxkZXJPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3QgYnJvd3Nlck9wdGlvbnMgPVxuICAgIGF3YWl0IGNvbnRleHQuZ2V0VGFyZ2V0T3B0aW9ucyhicm93c2VyVGFyZ2V0KSBhcyB1bmtub3duIGFzIEJyb3dzZXJCdWlsZGVyT3B0aW9ucztcbiAgY29uc3QgdHNDb25maWdQYXRoID1cbiAgICB0eXBlb2YgYnJvd3Nlck9wdGlvbnMudHNDb25maWcgPT09ICdzdHJpbmcnID8gYnJvd3Nlck9wdGlvbnMudHNDb25maWcgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgcm91dGVzID0gYXdhaXQgZ2V0Um91dGVzKG9wdGlvbnMsIHRzQ29uZmlnUGF0aCwgY29udGV4dCk7XG4gIGlmICghcm91dGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IHJvdXRlcyB0byBwcmVyZW5kZXIuYCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfc2NoZWR1bGVCdWlsZHMob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHsgc3VjY2VzcywgZXJyb3IsIGJyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdCB9ID0gcmVzdWx0O1xuICBpZiAoIXN1Y2Nlc3MgfHwgIWJyb3dzZXJSZXN1bHQgfHwgIXNlcnZlclJlc3VsdCkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGVycm9yIH0gYXMgQnVpbGRlck91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyVW5pdmVyc2FsKFxuICAgIHJvdXRlcyxcbiAgICBjb250ZXh0LFxuICAgIGJyb3dzZXJSZXN1bHQsXG4gICAgc2VydmVyUmVzdWx0LFxuICAgIGJyb3dzZXJPcHRpb25zLFxuICAgIG9wdGlvbnMubnVtUHJvY2Vzc2VzLFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyKGV4ZWN1dGUpO1xuIl19